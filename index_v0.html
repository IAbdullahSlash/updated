<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <title>SafeBrowse</title>
    <link rel="stylesheet" href="styles/StylingNothingg.css">
    <!--  text extraction libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.0/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <style>

        .loading-dots {
            display: inline-block;
        }
        
        .loading-dots::after {
            content: '';
            animation: dots 1.5s infinite;
        }
        
        @keyframes dots {
            0% { content: ''; }
            25% { content: '.'; }
            50% { content: '..'; }
            75% { content: '...'; }
            100% { content: ''; }
        }
        
        .stop-btn svg {
            width: 20px;
            height: 20px;
        }
        
        .stop-btn {
            background-color: #d32f2f !important;
        }
        
        .stop-btn:hover {
            background-color: #b71c1c !important;
        }
        
        .file-progress {
            margin-top: 5px;
            height: 4px;
            width: 100%;
            background-color: #f0f0f0;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .file-progress-bar {
            height: 100%;
            width: 0%;
            background-color: #4361ee;
            transition: width 0.3s ease;
        }
        
        .file-icon {
            display: inline-block;
            margin-right: 5px;
            font-weight: bold;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.8em;
            color: white;
        }
        
        .file-icon.pdf {
            background-color: #e53935;
        }
        
        .file-icon.ppt {
            background-color: #ff8f00;
        }
        
        .file-icon.doc {
            background-color: #1565c0;
        }
        
        .file-icon.txt {
            background-color: #546e7a;
        }

        /* Copy button styles */
        .message-content {
            position: relative;
        }

        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: transparent;
            border: none;
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.2s;
            color: #555;
            display: none;
            padding: 4px;
            border-radius: 4px;
        }

        .message-content:hover .copy-btn {
            display: block;
        }

        .copy-btn:hover {
            opacity: 1;
            background-color: rgba(0, 0, 0, 0.05);
        }

        .copy-success-message {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #4caf50;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            z-index: 1000;
            animation: fadeInOut 2s ease-in-out;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; }
            15% { opacity: 1; }
            85% { opacity: 1; }
            100% { opacity: 0; }
        }
        .nav-links{
            font-weight: bold;
        }

        .audio-recorder {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
            padding: 24px;
            width: 340px;
            z-index: 1000;
            display: none;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .audio-recorder.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        .audio-recorder-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);
            padding-bottom: 12px;
        }

        .audio-recorder-title {
            font-weight: 600;
            font-size: 18px;
            color: #333;
            display: flex;
            align-items: center;
        }

        .audio-recorder-title svg {
            margin-right: 8px;
            color: #311a1b;
        }

        .close-recorder {
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 22px;
            color: #666;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .close-recorder:hover {
            background-color: rgba(0, 0, 0, 0.05);
            color: #333;
        }

        .recorder-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .record-btn, .stop-record-btn, .send-audio-btn {
            margin: 8px 0;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            width: 100%;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 15px;
        }

        .record-btn svg, .stop-record-btn svg, .send-audio-btn svg {
            margin-right: 8px;
        }

        .record-btn {
            background-color: #311a1b;
            color: white;
        }

        .record-btn:hover {
            background-color: #ceb6b6;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(67, 97, 238, 0.2);
        }

        .stop-record-btn {
            background-color: #311a1b;
            color: white;
            display: none;
        }

        .stop-record-btn:hover {
            background-color: #ceb6b6;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(211, 47, 47, 0.2);
        }

        .send-audio-btn {
            background-color: #311a1b;
            color: white;
            display: none;
        }

        .send-audio-btn:hover {
            background-color: #ceb6b6;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(76, 175, 80, 0.2);
        }

        .recording-status {
            margin: 16px 0;
            text-align: center;
            color: #666;
            font-size: 14px;
        }

        .recording-time {
            font-size: 16px;
            font-weight: 600;
            color: #311a1b;
            margin-top: 6px;
        }

        .recording-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            background-color: #d32f2f;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(211, 47, 47, 0.7);
            }
            
            70% {
                transform: scale(1);
                box-shadow: 0 0 0 6px rgba(211, 47, 47, 0);
            }
            
            100% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(211, 47, 47, 0);
            }
        }

        .audio-preview {
            width: 100%;
            margin-top: 16px;
            display: none;
            border-radius: 8px;
            background-color: #f5f5f5;
            height: 40px;
        }

        .audio-preview::-webkit-media-controls-panel {
            background-color: #f5f5f5;
        }

        /* Removed audio-visualizer and visualizer-bar styles */

        .recorder-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .recorder-overlay.show {
            opacity: 1;
        }

        /* Responsive adjustments */
        @media (max-width: 480px) {
            .audio-recorder {
                width: 90%;
                max-width: 340px;
                padding: 20px;
            }
        }

        .attachment-options {
            display: none;
            position: absolute;
            bottom: 80px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 8px;
            z-index: 100;
        }

        .attachment-options.show {
            display: block;
            animation: fadeIn 0.2s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .attachment-option {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            border: none;
            background: transparent;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            text-align: left;
            transition: background-color 0.2s;
        }

        .attachment-option:hover {
            background-color: #f5f5f5;
        }

        .attachment-icon {
            margin-right: 8px;
            width: 18px;
            height: 18px;
        }
    </style>
</head>
<body>
    <div class="overlay"></div>
    <div class="sidebar">
        <button class="new-chat">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
            New chat
        </button>
        <div class="recent-label">Recent</div>
        <ul class="chat-list">
            <li><a href="#" class="chat-item">What is harmful content?</a></li>
            <li><a href="#" class="chat-item">Classify harmful content</a></li>
            <li><a href="#" class="chat-item">How does AI detect and recognize such content?</a></li>
        </ul>
        <div class="show-more">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
            Show more
        </div>
    </div>

    <header class="header">
        <nav class="nav">
            <div style="display: flex; align-items: center;">
                <svg class="sidebar-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
                <span><a href="page1.html" class="title">SafeBrowse</a></span>
            </div>
            <div class="nav-links">
                <a href="page1.html">Home</a>
                <a href="page1.html#about">About us</a>
                <a href="login.html" class="btn-register">Register now</a>
            </div>
        </nav>
    </header>

    <section class="main">
        <div class="main-title">
            <h1>
                <span class="typing-text">Hello there, user!</span>
            </h1>
        </div>
        <p class="subtitle">How may I help you?</p>
        <div class="chat-background" style="display: none;">
            <div class="chat-messages">
                <div class="message-wrapper">
                </div>
            </div>
        </div>
    </section>

    <div class="chat-box fade-in">
        <form class="form" id="chatForm">                           
            <div class="search">
            <input 
                type="text" 
                class="chat-input" 
                id="chatInput"
                placeholder="Type your message..."
                required
            >
            </div>
            <div class="button-group">
                <button type="button" class="attach-btn" aria-label="Attach file">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
                    </svg>
                </button>
                <button type="submit" class="submit-btn" id="submitBtn" aria-label="Send">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="22" y1="2" x2="11" y2="13"></line>
                        <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                    </svg>
                </button>
            </div>
        </form>
        <div class="attachment-options">
            <button type="button" class="attachment-option" data-type="file">
                <svg class="attachment-icon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path>
                    <polyline points="14 2 14 8 20 8"></polyline>
                </svg>
                <span>File</span>
            </button>
            <button type="button" class="attachment-option" data-type="image">
                <svg class="attachment-icon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                    <circle cx="8.5" cy="8.5" r="1.5"></circle>
                    <polyline points="21 15 16 10 5 21"></polyline>
                </svg>
                <span>Image</span>
            </button>
            <button type="button" class="attachment-option" data-type="audio">
                <svg class="attachment-icon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                    <line x1="12" y1="19" x2="12" y2="23"></line>
                    <line x1="8" y1="23" x2="16" y2="23"></line>
                </svg>
                <span>Audio</span>
            </button>
        </div>
    </div>
    
    <div class="disclaimer">
        AI responses may not be 100% accurate. Please verify important information from trusted sources.
    </div>
    
    <input type="file" id="fileInput" style="display: none;" accept=".txt,.pdf,.doc,.docx,.pptx">
    <input type="file" id="imageInput" style="display: none;" accept="image/*">
    <input type="file" id="audioInput" style="display: none;" accept="audio/*">

    <!-- Audio Recorder Modal -->
    <div class="recorder-overlay" id="recorderOverlay"></div>
    <div class="audio-recorder" id="audioRecorder">
        <div class="audio-recorder-header">
            <div class="audio-recorder-title">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                    <line x1="12" y1="19" x2="12" y2="23"></line>
                    <line x1="8" y1="23" x2="16" y2="23"></line>
                </svg>
                Record Audio
            </div>
            <button class="close-recorder" id="closeRecorder">×</button>
        </div>
        <div class="recording-status">
            <span id="recordingStatus">Ready to record</span>
            <div class="recording-time" id="recordingTime"></div>
        </div>
        <div class="recorder-controls">
            <button class="record-btn" id="startRecording">
                Start Recording
            </button>
            <button class="stop-record-btn" id="stopRecording">
                Stop Recording
            </button>
            <audio id="audioPreview" class="audio-preview" controls></audio>
            <button class="send-audio-btn" id="sendAudio">
                Send Audio
            </button>
        </div>
    </div>

    <script>
        if (window.pdfjsLib) {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';
        }

        // Sidebar toggle functionality
        const sidebarIcon = document.querySelector('.sidebar-icon');
        const sidebar = document.querySelector('.sidebar');
        const overlay = document.querySelector('.overlay');

        function toggleSidebar() {
            sidebar.classList.toggle('open');
            overlay.classList.toggle('open');
        }

        sidebarIcon.addEventListener('click', toggleSidebar);
        overlay.addEventListener('click', toggleSidebar);

        const API_KEY = "AIzaSyCqc3zIUa59r7UvNbn7gy6rhRXbsZ6NcxE";
        
        // Variable to store the current fetch controller for aborting requests
        let currentController = null;

        // Copy to clipboard functionality
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text)
                .then(() => {
                    showCopySuccess();
                })
                .catch(err => {
                    console.error('Failed to copy text: ', err);
                });
        }

        function showCopySuccess() {
            // success message
            const successMsg = document.createElement('div');
            successMsg.textContent = 'Copied to clipboard!';
            successMsg.className = 'copy-success-message';
            document.body.appendChild(successMsg);
            
            // Remove after 2 seconds
            setTimeout(() => {
                successMsg.remove();
            }, 2000);
        }

        async function initializeChat() {
            const history = [];
            const systemInstruction = "Your name is SafeBrowse. You are an AI agent responsible for detecting and recognizing all types of harmful content from whatever user provide. You should highlight such content, provide corrections, and suggest appropriate actions accordingly. You were made by the team 404 fixers. If data has been given with the intention not related to your main mission, you should just explain why it's not from your expertise. Also, tell about yourself only when asked.";

            // system instruction to history
            history.push({ role: 'SafeBrowse', content: systemInstruction });

            return { history };
        }

        let chatState;
        let isGenerating = false;

        // Initialize chat when the page loads
        window.addEventListener('load', async () => {
            chatState = await initializeChat();
            
            // Add responsive handling for window resize
            handleWindowResize();
            window.addEventListener('resize', handleWindowResize);
            
            const fadeElements = document.querySelectorAll('.fade-in');
            fadeElements.forEach((element, index) => {
                setTimeout(() => {
                    element.style.opacity = '1';
                }, index * 200);
            });
        });
        
        function handleWindowResize() {
            const isMobile = window.innerWidth <= 768;
            const chatBackground = document.querySelector('.chat-background');
            
            if (chatBackground && chatBackground.style.display !== 'none') {
                if (isMobile) {
                    document.querySelector('.main').style.height = '100vh';
                } else {
                    document.querySelector('.main').style.height = '20em';
                }
            }
        }

        function typeMessage(element, text, speed = 30) {
            let i = 0;
            element.innerHTML = 'SB:<br>'; 
            
            function type() {
                if (i < text.length && isGenerating) {
                    if (text.charAt(i) === '\n') {
                        element.innerHTML += '<br>';
                    } else {
                        element.innerHTML += text.charAt(i);
                    }
                    i++;
                    scrollToBottom();
                    setTimeout(type, speed);
                } else if (i >= text.length) {
                    // Typing is complete, reset the button
                    resetSendButton();
                    
                    // Add copy button after typing is complete
                    const messageContent = element.closest('.message-content');
                    if (messageContent && !messageContent.querySelector('.copy-btn')) {
                        const copyBtn = document.createElement('button');
                        copyBtn.className = 'copy-btn';
                        copyBtn.setAttribute('aria-label', 'Copy to clipboard');
                        copyBtn.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        `;
                        
                        // Store the full text for copying 
                        const fullText = text;
                        
                        copyBtn.addEventListener('click', () => {
                            copyToClipboard(fullText);
                        });
                        
                        messageContent.appendChild(copyBtn);
                    }
                }
            }
            
            type();
        }
        
        // Function to convert send button to stop button
        function convertToStopButton() {
            const submitBtn = document.getElementById('submitBtn');
            submitBtn.classList.add('stop-btn');
            submitBtn.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="6" y="6" width="12" height="12" />
                </svg>
            `;
            submitBtn.setAttribute('aria-label', 'Stop');
            
            // 0button event listener
            submitBtn.removeEventListener('click', handleSubmit);
            submitBtn.addEventListener('click', stopGeneration);
            
            isGenerating = true;
        }
        
        // Function to reset send button
        function resetSendButton() {
            const submitBtn = document.getElementById('submitBtn');
            submitBtn.classList.remove('stop-btn');
            submitBtn.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="22" y1="2" x2="11" y2="13"></line>
                    <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                </svg>
            `;
            submitBtn.setAttribute('aria-label', 'Send');
            
            // Reset the button's event listener
            submitBtn.removeEventListener('click', stopGeneration);
            submitBtn.addEventListener('click', handleSubmit);
            
            isGenerating = false;
        }
        
        // Function to stop generation
        function stopGeneration(e) {
            e.preventDefault();
            if (currentController) {
                currentController.abort();
                currentController = null;
            }
            isGenerating = false;
            resetSendButton();
            
            // Update the loading message to indicate it was stopped
            const loadingElement = document.querySelector('.loading-message');
            if (loadingElement) {
                loadingElement.innerHTML = `
                    <div class="message-content">
                        <i class="fa-solid fa-circle-user fa-2x"></i>     
                        <div class="message-text">
                            SB:<br>Response generation stopped.
                        </div>
                    </div>
                `;
            }
        }
        
        // Function to handle submit button
        async function handleSubmit(e) {
            if (e) e.preventDefault();
            if (isGenerating) return; // Prevent multiple submissions
            
            const message = document.getElementById('chatInput').value;
            if (!message.trim()) return; // prevent empty messages
            
            document.querySelector('.main-title').style.display = 'none';
            document.querySelector('.subtitle').style.display = 'none';
            document.querySelector('.chat-background').style.display = 'block';
            
            handleWindowResize();

            // Create a new message element
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', 'sender-message');
            messageElement.innerHTML = `
                <div class="message-content">
                    <i class="fa-solid fa-circle-user fa-2x"></i>
                    <div class="message-text">
                        YOU:<br>${message}
                    </div>
                </div>
            `;

            // Add the message element to the chat messages container
            const messageWrapper = document.querySelector('.message-wrapper');
            messageWrapper.appendChild(messageElement);
            
            scrollToBottom();

            // Clear input after sending
            document.getElementById('chatInput').value = ''; 
            
            // Create loading message with typing effect
            const loadingElement = document.createElement('div');
            loadingElement.classList.add('message', 'receiver-message', 'loading-message');
            loadingElement.innerHTML = `
                <div class="message-content">
                    <img src="Images/posslogo.jpg" alt="SafeBrowse" class="bot-avatar">
                    <div class="message-text">
                        SB:<br>Thinking<span class="loading-dots"></span>
                    </div>
                </div>
            `;
            
            messageWrapper.appendChild(loadingElement);
            scrollToBottom();
            
            // Convert send button to stop button
            convertToStopButton();

            try {
                // Add user message to history
                chatState.history.push({ role: 'user', content: message });

                // Prepare the request body
                const requestBody = {
                    contents: [
                        {
                            parts: [
                                { text: chatState.history.map(msg => `${msg.role}: ${msg.content}`).join('\n') }
                            ]
                        }
                    ]
                };

                console.log('Request body:', JSON.stringify(requestBody, null, 2));
                
                // Create an AbortController to be able to cancel the fetch
                currentController = new AbortController();
                const signal = currentController.signal;

                // Generate response
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${API_KEY}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody),
                    signal: signal
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }

                const result = await response.json();
                console.log('API response:', JSON.stringify(result, null, 2));

                if (!result.candidates || result.candidates.length === 0) {
                    throw new Error('No response generated from the AI.');
                }

                const botResponse = result.candidates[0].content.parts[0].text;

                chatState.history.push({ role: 'SafeBrowse', content: botResponse });

                messageWrapper.removeChild(loadingElement);
                
                // Create and add bot response element
                const responseElement = document.createElement('div');
                responseElement.classList.add('message', 'receiver-message');
                responseElement.innerHTML = `
                    <div class="message-content">
                        <img src="Images/posslogo.jpg" alt="SafeBrowse" class="bot-avatar">
                        <div class="message-text">
                            SB:<br>
                        </div>
                    </div>
                `;
                
                // Add the response element to the chat messages container
                messageWrapper.appendChild(responseElement);
                
                // Apply typing effect to the message text
                const messageTextElement = responseElement.querySelector('.message-text');
                typeMessage(messageTextElement, botResponse);
                
                scrollToBottom();
            } catch (error) {
                // Only display error if it's not an abort error
                if (error.name !== 'AbortError') {
                    console.error('Error:', error);
                    
                    messageWrapper.removeChild(loadingElement);
                    
                    const errorElement = document.createElement('div');
                    errorElement.classList.add('message', 'error-message');
                    errorElement.innerHTML = `
                        <div class="message-content">
                            <div class="message-text">
                                Error: ${error.message || 'Unable to get response from the AI.'}
                            </div>
                        </div>
                    `;
                    messageWrapper.appendChild(errorElement);
                    
                    scrollToBottom();
                }
                
                // Reset the send button
                resetSendButton();
            }
        }

        // Attach the submit handler to the form
        document.getElementById('chatForm').addEventListener('submit', handleSubmit);

        // File handling
        const fileInput = document.getElementById('fileInput');
        const imageInput = document.getElementById('imageInput');
        const audioInput = document.getElementById('audioInput');

        // Attachment button functionality
        const attachBtn = document.querySelector('.attach-btn');
        const attachmentOptions = document.querySelector('.attachment-options');

        attachBtn.addEventListener('click', () => {
            attachmentOptions.classList.toggle('show');
        });

        document.addEventListener('click', (e) => {
            if (!attachBtn.contains(e.target) && !attachmentOptions.contains(e.target)) {
                attachmentOptions.classList.remove('show');
            }
        });

        const attachmentOptionBtns = document.querySelectorAll('.attachment-option');
        attachmentOptionBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const type = btn.dataset.type;
                if (type === 'file') {
                    fileInput.click();
                    document.querySelector('.main-title').style.display = 'none';
                    document.querySelector('.subtitle').style.display = 'none';
                    document.querySelector('.chat-background').style.display = 'block';
                } else if (type === 'image') {
                    imageInput.click();
                    document.querySelector('.main-title').style.display = 'none';
                    document.querySelector('.subtitle').style.display = 'none';
                    document.querySelector('.chat-background').style.display = 'block';
                } else if (type === 'audio') {
                    // Show audio recorder instead of file input
                    showAudioRecorder();
                    document.querySelector('.main-title').style.display = 'none';
                    document.querySelector('.subtitle').style.display = 'none';
                    document.querySelector('.chat-background').style.display = 'block';
                }
                attachmentOptions.classList.remove('show');
            });
        });

        fileInput.addEventListener('change', handleFileUpload);
        imageInput.addEventListener('change', handleImageUpload);
        audioInput.addEventListener('change', handleAudioUpload);

        // Helper function to get file type icon
        function getFileTypeIcon(fileName) {
            const extension = fileName.split('.').pop().toLowerCase();
            let iconClass = 'txt';
            
            if (extension === 'pdf') {
                iconClass = 'pdf';
            } else if (['ppt', 'pptx'].includes(extension)) {
                iconClass = 'ppt';
            } else if (['doc', 'docx'].includes(extension)) {
                iconClass = 'doc';
            }
            
            return `<span class="file-icon ${iconClass}">${extension.toUpperCase()}</span>`;
        }

        // Function to extract text from DOCX files
        async function extractTextFromDOCX(arrayBuffer) {
            try {
                if (!window.mammoth) {
                    console.error("Mammoth.js library not loaded");
                    return "Error: Text extraction library not loaded. Please refresh the page.";
                }
                
                const result = await window.mammoth.extractRawText({ arrayBuffer });
                return result.value;
            } catch (error) {
                console.error("Error extracting DOCX text:", error);
                return "Error extracting text from DOCX file: " + error.message;
            }
        }

        // <---- EXTRACTION SECTION ---->
        // Function to extract text from PDF files
        async function extractTextFromPDF(arrayBuffer) {
            try {
                if (!window.pdfjsLib) {
                    console.error("PDF.js library not loaded");
                    return "Error: PDF extraction library not loaded. Please refresh the page.";
                }
                
                const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                let text = "";
                
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const content = await page.getTextContent();
                    const pageText = content.items.map(item => item.str).join(" ");
                    text += pageText + "\n\n";
                }
                
                return text;
            } catch (error) {
                console.error("Error extracting PDF text:", error);
                return "Error extracting text from PDF file: " + error.message;
            }
        }

        // ppt & error handling 
        async function extractTextFromPPTX(arrayBuffer) {
            try {
                if (!window.JSZip) {
                    console.error("JSZip library not loaded");
                    return "Error: PPTX extraction library not loaded. Please refresh the page.";
                }
                
                const zip = await window.JSZip.loadAsync(arrayBuffer);
                let text = "";
                
                // PPTX files store slide content in ppt/slides/slide*.xml files
                const slideFiles = Object.keys(zip.files).filter(name => 
                    name.startsWith("ppt/slides/slide") && name.endsWith(".xml")
                );
                
                for (const slideFile of slideFiles) {
                    const content = await zip.file(slideFile).async("string");
                    // Extract text from XML 
                    const textMatches = content.match(/<a:t>([^<]*)<\/a:t>/g) || [];
                    const slideText = textMatches
                        .map(match => match.replace(/<a:t>|<\/a:t>/g, ""))
                        .join(" ");
                    
                    text += "Slide " + slideFile.match(/slide(\d+)/)[1] + ":\n" + slideText + "\n\n";
                }
                
                return text || "No text content found in PPTX file";
            } catch (error) {
                console.error("Error extracting PPTX text:", error);
                return "Error extracting text from PPTX file: " + error.message;
            }
        }

        // Function to extract text from DOC files
        async function extractTextFromDOC(arrayBuffer) {
            const uint8Array = new Uint8Array(arrayBuffer);
            let text = "";
            
            // text chunks in the binary data
            for (let i = 0; i < uint8Array.length; i++) {
                if (uint8Array[i] >= 32 && uint8Array[i] <= 126) {
                    text += String.fromCharCode(uint8Array[i]);
                } else if (uint8Array[i] === 13 || uint8Array[i] === 10) {
                    text += "\n";
                }
            }
            
            // removing non word sequence
            text = text.replace(/[^\w\s.,;:!?'"()\[\]{}\-–—]/g, " ")
                    .replace(/\s+/g, " ")
                    .trim();
            
            return text || "Limited text extraction from DOC file. Consider converting to DOCX for better results.";
        }

        // Main function to handle file extraction based on type
        async function extractTextFromFile(file) {
            const arrayBuffer = await file.arrayBuffer();
            const fileExtension = file.name.split('.').pop().toLowerCase();
            
            console.log(`Extracting text from ${fileExtension.toUpperCase()} file: ${file.name}`);
            
            switch (fileExtension) {
                case 'docx':
                    return extractTextFromDOCX(arrayBuffer);
                case 'doc':
                    return extractTextFromDOC(arrayBuffer);
                case 'pptx':
                    return extractTextFromPPTX(arrayBuffer);
                case 'ppt':
                    return "PPT files (older PowerPoint format) have limited support. Consider converting to PPTX for better results.";
                case 'pdf':
                    return extractTextFromPDF(arrayBuffer);
                case 'txt':
                    return new TextDecoder().decode(arrayBuffer);
                default:
                    return `Unsupported file type: ${fileExtension}`;
            }
        }

        // File upload handler that works with binary files
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Show the chat interface
            document.querySelector('.main-title').style.display = 'none';
            document.querySelector('.subtitle').style.display = 'none';
            document.querySelector('.chat-background').style.display = 'block';
            
            // Create a message element for the file upload with progress indicator
            const messageWrapper = document.querySelector('.message-wrapper');
            const uploadElement = document.createElement('div');
            uploadElement.classList.add('message', 'sender-message');
            
            const fileIcon = getFileTypeIcon(file.name);
            
            uploadElement.innerHTML = `
                <div class="message-content">
                    <i class="fa-solid fa-circle-user fa-2x"></i>

                    <div class="message-text">
                        YOU:<br>Uploading file: ${fileIcon} ${file.name} (${(file.size / 1024).toFixed(1)} KB)
                        <div class="file-progress">
                            <div class="file-progress-bar"></div>
                        </div>
                    </div>
                </div>
            `;
            
            messageWrapper.appendChild(uploadElement);
            scrollToBottom();
            
            const progressBar = uploadElement.querySelector('.file-progress-bar');
            progressBar.style.width = '30%';
            
            try {
                // Determine how to handle the file based on its type
                const fileExtension = file.name.split('.').pop().toLowerCase();
                
                // Update progress
                progressBar.style.width = '60%';
                
                let fileContent;
                
                if (['doc', 'docx', 'ppt', 'pptx', 'pdf'].includes(fileExtension)) {
                    // Extract text using our new functions
                    fileContent = await extractTextFromFile(file);
                    
                    // Update progress
                    progressBar.style.width = '100%';
                    
                    uploadElement.innerHTML = `
                        <div class="message-content">
                            <i class="fa-solid fa-circle-user fa-2x"></i>
                            <div class="message-text">
                                YOU:<br>Sent a file: ${fileIcon} ${file.name}
                            </div>
                        </div>
                    `;
                    
                    // Send the extracted text to the AI
                    const message = `Please review this ${fileExtension.toUpperCase()} file: ${file.name}\n\nExtracted content:\n${fileContent}`;
                    await sendMessageToAI(message, `Sent a file: ${fileIcon} ${file.name}`);
                } else if (fileExtension === 'txt') {
                    // For text files, use the text reader
                    await readFileAsText(file, progressBar, uploadElement);
                } else {
                    const reader = new FileReader();
                    
                    reader.onprogress = (event) => {
                        if (event.lengthComputable) {
                            const progress = (event.loaded / event.total) * 100;
                            progressBar.style.width = `${progress}%`;
                        }
                    };
                    
                    reader.onload = async (e) => {
                        progressBar.style.width = '100%';
                        
                        uploadElement.innerHTML = `
                            <div class="message-content">
                                <i class="fa-solid fa-circle-user fa-2x"></i>

                                <div class="message-text">
                                    YOU:<br>Sent a file: ${fileIcon} ${file.name}
                                </div>
                            </div>
                        `;
                        
                        // Send a generic message for unsupported file types
                        const message = `I've uploaded a file: ${file.name} (${fileExtension.toUpperCase()} format). Please analyze it if possible.`;
                        await sendMessageToAI(message, `Sent a file: ${fileIcon} ${file.name}`);
                    };
                    
                    reader.onerror = () => {
                        throw new Error('Error reading the file');
                    };
                    
                    reader.readAsArrayBuffer(file);
                }
            } catch (error) {
                console.error('Error processing file:', error);
                uploadElement.innerHTML = `
                    <div class="message-content">
                        <i class="fa-solid fa-circle-user fa-2x"></i>

                        <div class="message-text">
                            YOU:<br>Failed to process file: ${file.name} - ${error.message}
                        </div>
                    </div>
                `;
                displayErrorMessage(error);
            }
        }
        
        // Function to read text files
        async function readFileAsText(file, progressBar, uploadElement) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onprogress = (event) => {
                    if (event.lengthComputable) {
                        const progress = (event.loaded / event.total) * 100;
                        progressBar.style.width = `${progress}%`;
                    }
                };
                
                reader.onload = async (e) => {
                    try {
                        progressBar.style.width = '100%';
                        const fileContent = e.target.result;
                        
                        const fileIcon = getFileTypeIcon(file.name);
                        uploadElement.innerHTML = `
                            <div class="message-content">
                                <i class="fa-solid fa-circle-user fa-2x"></i>

                                <div class="message-text">
                                    YOU:<br>Sent a file: ${fileIcon} ${file.name}
                                </div>
                            </div>
                        `;
                        
                        // Send the text file content to the AI
                        const message = `Please review this text file: ${file.name}\n\nFile content:\n${fileContent}`;
                        await sendMessageToAI(message, `Sent a file: ${fileIcon} ${file.name}`);
                        resolve();
                    } catch (error) {
                        reject(error);
                    }
                };
                
                reader.onerror = () => {
                    reject(new Error('Error reading the file'));
                };
                
                reader.readAsText(file);
            });
        }

        async function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                const imageContent = e.target.result;
                await sendImageToAI(file.name, imageContent);
            };
            reader.readAsDataURL(file);
        }

        async function handleAudioUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const audioContent = e.target.result;
                    await sendAudioToAI(file.name, audioContent);
                    
                    // Update the loading message
                    loadingElement.innerHTML = `
                        <div class="message-content">
                            <i class="fa-solid fa-circle-user fa-2x"></i>

                            <div class="message-text">
                                YOU:<br>Sent an audio file: ${file.name}
                            </div>
                        </div>
                    `;
                };
                reader.readAsDataURL(file);
            } catch (error) {
                console.error('Error processing audio:', error);
                loadingElement.innerHTML = `
                    <div class="message-content">
                        <i class="fa-solid fa-circle-user fa-2x"></i>             

                        <div class="message-text">
                            YOU:<br>Failed to process audio file: ${file.name}
                        </div>
                    </div>
                `;
                displayErrorMessage(error);
            }
        }

        async function sendImageToAI(fileName, imageContent) {
            try {
                const message = `Please analyze this image: ${fileName}`;
                const requestBody = {
                    contents: [
                        {
                            parts: [
                                { text: message },
                                { inline_data: { mime_type: "image/jpeg", data: imageContent.split(',')[1] } }
                            ]
                        }
                    ]
                };
                await sendRequestToAI(requestBody, `Sent an image: ${fileName}`);
            } catch (error) {
                console.error('Error sending image to AI:', error);
                displayErrorMessage(error);
            }
        }

        async function sendAudioToAI(fileName, audioContent) {
            try {
                // Extract base64 data from the data URL
                const base64Data = audioContent.split(',')[1];
                
                // Determine the MIME type from the data URL
                const mimeType = audioContent.match(/data:(.*?);/)[1] || "audio/mpeg";
                
                const message = `Please analyze this audio file: ${fileName}`;
                
                // Create request body with audio data
                const requestBody = {
                    contents: [
                        {
                            parts: [
                                { text: message },
                                { inline_data: { mime_type: mimeType, data: base64Data } }
                            ]
                        }
                    ]
                };
                
                // Add to chat history
                chatState.history.push({ 
                    role: 'user', 
                    content: `[Uploaded audio file: ${fileName}] ${message}` 
                });
                
                // Send to AI
                await sendRequestToAI(requestBody, `Sent an audio file: ${fileName}`);
            } catch (error) {
                console.error('Error sending audio to AI:', error);
                displayErrorMessage(error);
            }
        }

        async function sendMessageToAI(message, displayMessage) {
            chatState.history.push({ role: 'user', content: message });
            const requestBody = {
                contents: [
                    {
                        parts: [
                            { text: chatState.history.map(msg => `${msg.role}: ${msg.content}`).join('\n') }
                        ]
                    }
                ]
            };
            await sendRequestToAI(requestBody, displayMessage);
        }

        async function sendRequestToAI(requestBody, displayMessage) {
            if (isGenerating) return; // Prevent multiple requests
            
            // Create a new message element for the file/image/audio
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', 'sender-message');
            messageElement.innerHTML = `
                <div class="message-content">
                    <i class="fa-solid fa-circle-user fa-2x"></i>

                    <div class="message-text">
                        YOU:<br>${displayMessage}
                    </div>
                </div>
            `;
     
            // Add the message element to the chat messages container
            const messageWrapper = document.querySelector('.message-wrapper');
            messageWrapper.appendChild(messageElement);
            
            scrollToBottom();
            
            // Create loading message with typing effect
            const loadingElement = document.createElement('div');
            loadingElement.classList.add('message', 'receiver-message', 'loading-message');
            loadingElement.innerHTML = `
                <div class="message-content">
                    <img src="Images/posslogo.jpg" alt="SafeBrowse" class="bot-avatar">
                    <div class="message-text">
                        SB:<br>Thinking<span class="loading-dots"></span>
                    </div>
                </div>
            `;
            
            
            messageWrapper.appendChild(loadingElement);
            scrollToBottom();
            
            // Convert send button to stop button
            convertToStopButton();

            console.log('Request body:', JSON.stringify(requestBody, null, 2));
            
            // Create an AbortController to be able to cancel the fetch
            currentController = new AbortController();
            const signal = currentController.signal;

            try {
                // Generate response
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${API_KEY}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody),
                    signal: signal
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }

                const result = await response.json();
                console.log('API response:', JSON.stringify(result, null, 2));

                if (!result.candidates || result.candidates.length === 0) {
                    throw new Error('No response generated from the AI.');
                }

                const botResponse = result.candidates[0].content.parts[0].text;

                chatState.history.push({ role: 'SafeBrowse', content: botResponse });
                
                messageWrapper.removeChild(loadingElement);

                // Create and add bot response element
                const responseElement = document.createElement('div');
                responseElement.classList.add('message', 'receiver-message');
                responseElement.innerHTML = `
                    <div class="message-content">
                        <img src="Images/posslogo.jpg" alt="SafeBrowse" class="bot-avatar">
                        <div class="message-text">
                            SB:<br>
                        </div>
                    </div>
                `;
                
                // Add the response element to the chat messages container
                messageWrapper.appendChild(responseElement);
                
                // Apply typing effect to the message text
                const messageTextElement = responseElement.querySelector('.message-text');
                typeMessage(messageTextElement, botResponse);
                
                scrollToBottom();
            } catch (error) {
                // Only display error if it's not an abort error
                if (error.name !== 'AbortError') {
                    console.error('Error:', error);
                    
                    messageWrapper.removeChild(loadingElement);
                    
                    const errorElement = document.createElement('div');
                    errorElement.classList.add('message', 'error-message');
                    errorElement.innerHTML = `
                        <div class="message-content">
                            <div class="message-text">
                                Error: ${error.message || 'Unable to get response from the AI.'}
                            </div>
                        </div>
                    `;
                    messageWrapper.appendChild(errorElement);
                    
                    scrollToBottom();
                }
                
                resetSendButton();
            }
        }

        function displayErrorMessage(error) {
            const errorElement = document.createElement('div');
            errorElement.classList.add('message', 'error-message');
            errorElement.innerHTML = `
                <div class="message-content">
                    <div class="message-text">
                        Error: ${error.message || 'Unable to get response from the AI.'}
                    </div>
                </div>
            `;
            const messageWrapper = document.querySelector('.message-wrapper');
            messageWrapper.appendChild(errorElement);
            
            scrollToBottom();
        }

        // function to scroll chat to bottom
        function scrollToBottom() {
            const chatMessages = document.querySelector('.chat-messages');
            if (chatMessages) {
                // Use requestAnimationFrame for smoother scrolling
                requestAnimationFrame(() => {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                });
            }
        }

        // Audio Recorder Functionality
        let mediaRecorder;
        let audioChunks = [];
        let recordingTimer;
        let recordingTime = 0;
        let audioBlob;
        let audioURL;
        let audioStream;
        let audioContext;
        let analyser;

        // Audio recorder UI elements
        const audioRecorder = document.getElementById('audioRecorder');
        const recorderOverlay = document.getElementById('recorderOverlay');
        const closeRecorder = document.getElementById('closeRecorder');
        const startRecording = document.getElementById('startRecording');
        const stopRecording = document.getElementById('stopRecording');
        const sendAudio = document.getElementById('sendAudio');
        const audioPreview = document.getElementById('audioPreview');
        const recordingStatus = document.getElementById('recordingStatus');
        const recordingTimeDisplay = document.getElementById('recordingTime');

        // audio recorder animation
        function showAudioRecorder() {
            resetAudioRecorder();
            recorderOverlay.style.display = 'block';
            audioRecorder.style.display = 'block';
            
            // Trigger reflow for animation
            void audioRecorder.offsetWidth;
            
            // animation classes
            recorderOverlay.classList.add('show');
            audioRecorder.classList.add('show');
        }

        // Close audio recorder with animation
        function closeAudioRecorder() {
            stopAudioRecording();
            
            // Remove animation classes
            recorderOverlay.classList.remove('show');
            audioRecorder.classList.remove('show');
            
            // Wait for animation to complete before hiding
            setTimeout(() => {
                audioRecorder.style.display = 'none';
                recorderOverlay.style.display = 'none';
            }, 300);
            
            // Clean up resources
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }
            
            if (audioContext) {
                audioContext.close().catch(err => console.error('Error closing audio context:', err));
                audioContext = null;
            }
            
            if (audioURL) {
                URL.revokeObjectURL(audioURL);
                audioURL = null;
            }
        }

        // Reset audio recorder
        function resetAudioRecorder() {
            audioChunks = [];
            recordingTime = 0;
            audioBlob = null;
            audioURL = null;
            
            startRecording.style.display = 'block';
            stopRecording.style.display = 'none';
            sendAudio.style.display = 'none';
            audioPreview.style.display = 'none';
            audioPreview.src = '';
            recordingStatus.innerHTML = 'Ready to record';
            recordingTimeDisplay.textContent = '';
        }

        // Start audio recording
        async function startAudioRecording() {
            try {
                resetAudioRecorder();
                
                // Request microphone access
                audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Set up audio context for visualizer
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(audioStream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                
                // Create media recorder
                mediaRecorder = new MediaRecorder(audioStream);
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    // Create audio blob and URL
                    audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    audioURL = URL.createObjectURL(audioBlob);
                    
                    audioPreview.src = audioURL;
                    audioPreview.style.display = 'block';
                    sendAudio.style.display = 'block';
                    recordingStatus.textContent = 'Recording complete';
                    
                    // Stop the timer
                    clearInterval(recordingTimer);
                };
                
                // Start recording
                mediaRecorder.start();
                
                startRecording.style.display = 'none';
                stopRecording.style.display = 'block';
                recordingStatus.innerHTML = '<span class="recording-indicator"></span> Recording...';
                
                // Start timer
                recordingTime = 0;
                updateRecordingTime();
                recordingTimer = setInterval(updateRecordingTime, 1000);
                
            } catch (error) {
                console.error('Error starting audio recording:', error);
                recordingStatus.textContent = 'Error: ' + error.message;
            }
        }

        // Stop audio recording
        function stopAudioRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                
                // Stop all tracks
                if (audioStream) {
                    audioStream.getTracks().forEach(track => track.stop());
                }
                
                // Clear timer
                clearInterval(recordingTimer);
            }
        }

        // Update recording time display
        function updateRecordingTime() {
            recordingTime++;
            const minutes = Math.floor(recordingTime / 60);
            const seconds = recordingTime % 60;
            recordingTimeDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Send recorded audio
        async function sendRecordedAudio() {
            if (!audioBlob) return;
            
            try {
                // Convert blob to base64
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const base64Audio = e.target.result;
                    
                    // Generate a filename with timestamp
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    const fileName = `recording-${timestamp}.webm`;
                    
                    // Send to AI
                    await sendAudioToAI(fileName, base64Audio);
                    
                    // Close recorder
                    closeAudioRecorder();
                };
                reader.readAsDataURL(audioBlob);
            } catch (error) {
                console.error('Error sending recorded audio:', error);
                recordingStatus.textContent = 'Error: ' + error.message;
            }
        }

        // Event listeners for audio recorder
        closeRecorder.addEventListener('click', closeAudioRecorder);
        recorderOverlay.addEventListener('click', (e) => {
            // overley clikcing closes the recorder
            if (e.target === recorderOverlay) {
                closeAudioRecorder();
            }
        });
        startRecording.addEventListener('click', startAudioRecording);
        stopRecording.addEventListener('click', stopAudioRecording);
        sendAudio.addEventListener('click', sendRecordedAudio);
    </script>
</body>
</html>